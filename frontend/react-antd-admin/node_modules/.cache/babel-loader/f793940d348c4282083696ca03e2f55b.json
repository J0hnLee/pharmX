{"ast":null,"code":"!function (e, t) {\n  if (\"object\" == typeof exports && \"object\" == typeof module) module.exports = t(require(\"react\"));else if (\"function\" == typeof define && define.amd) define([\"react\"], t);else {\n    var r = t(\"object\" == typeof exports ? require(\"react\") : e.React);\n\n    for (var o in r) (\"object\" == typeof exports ? exports : e)[o] = r[o];\n  }\n}(this, function (e) {\n  return function (e) {\n    function t(o) {\n      if (r[o]) return r[o].exports;\n      var n = r[o] = {\n        i: o,\n        l: !1,\n        exports: {}\n      };\n      return e[o].call(n.exports, n, n.exports, t), n.l = !0, n.exports;\n    }\n\n    var r = {};\n    return t.m = e, t.c = r, t.d = function (e, r, o) {\n      t.o(e, r) || Object.defineProperty(e, r, {\n        configurable: !1,\n        enumerable: !0,\n        get: o\n      });\n    }, t.n = function (e) {\n      var r = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return t.d(r, \"a\", r), r;\n    }, t.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, t.p = \"\", t(t.s = 0);\n  }([function (e, t, r) {\n    r(1), e.exports = r(2);\n  }, function (e, t) {\n    !function (e) {\n      \"use strict\";\n\n      function t(e) {\n        if (\"string\" != typeof e && (e += \"\"), /[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(e)) throw new TypeError(\"Invalid character in header field name\");\n        return e.toLowerCase();\n      }\n\n      function r(e) {\n        return \"string\" != typeof e && (e += \"\"), e;\n      }\n\n      function o(e) {\n        var t = {\n          next: function () {\n            var t = e.shift();\n            return {\n              done: void 0 === t,\n              value: t\n            };\n          }\n        };\n        return m.iterable && (t[Symbol.iterator] = function () {\n          return t;\n        }), t;\n      }\n\n      function n(e) {\n        this.map = {}, e instanceof n ? e.forEach(function (e, t) {\n          this.append(t, e);\n        }, this) : Array.isArray(e) ? e.forEach(function (e) {\n          this.append(e[0], e[1]);\n        }, this) : e && Object.getOwnPropertyNames(e).forEach(function (t) {\n          this.append(t, e[t]);\n        }, this);\n      }\n\n      function i(e) {\n        if (e.bodyUsed) return Promise.reject(new TypeError(\"Already read\"));\n        e.bodyUsed = !0;\n      }\n\n      function a(e) {\n        return new Promise(function (t, r) {\n          e.onload = function () {\n            t(e.result);\n          }, e.onerror = function () {\n            r(e.error);\n          };\n        });\n      }\n\n      function s(e) {\n        var t = new FileReader(),\n            r = a(t);\n        return t.readAsArrayBuffer(e), r;\n      }\n\n      function u(e) {\n        var t = new FileReader(),\n            r = a(t);\n        return t.readAsText(e), r;\n      }\n\n      function c(e) {\n        for (var t = new Uint8Array(e), r = Array(t.length), o = 0; t.length > o; o++) r[o] = String.fromCharCode(t[o]);\n\n        return r.join(\"\");\n      }\n\n      function d(e) {\n        if (e.slice) return e.slice(0);\n        var t = new Uint8Array(e.byteLength);\n        return t.set(new Uint8Array(e)), t.buffer;\n      }\n\n      function f() {\n        return this.bodyUsed = !1, this._initBody = function (e) {\n          if (this._bodyInit = e, e) {\n            if (\"string\" == typeof e) this._bodyText = e;else if (m.blob && Blob.prototype.isPrototypeOf(e)) this._bodyBlob = e;else if (m.formData && FormData.prototype.isPrototypeOf(e)) this._bodyFormData = e;else if (m.searchParams && URLSearchParams.prototype.isPrototypeOf(e)) this._bodyText = \"\" + e;else if (m.arrayBuffer && m.blob && w(e)) this._bodyArrayBuffer = d(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer]);else {\n              if (!m.arrayBuffer || !ArrayBuffer.prototype.isPrototypeOf(e) && !g(e)) throw Error(\"unsupported BodyInit type\");\n              this._bodyArrayBuffer = d(e);\n            }\n          } else this._bodyText = \"\";\n          this.headers.get(\"content-type\") || (\"string\" == typeof e ? this.headers.set(\"content-type\", \"text/plain;charset=UTF-8\") : this._bodyBlob && this._bodyBlob.type ? this.headers.set(\"content-type\", this._bodyBlob.type) : m.searchParams && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\"));\n        }, m.blob && (this.blob = function () {\n          var e = i(this);\n          if (e) return e;\n          if (this._bodyBlob) return Promise.resolve(this._bodyBlob);\n          if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n          if (this._bodyFormData) throw Error(\"could not read FormData body as blob\");\n          return Promise.resolve(new Blob([this._bodyText]));\n        }, this.arrayBuffer = function () {\n          return this._bodyArrayBuffer ? i(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(s);\n        }), this.text = function () {\n          var e = i(this);\n          if (e) return e;\n          if (this._bodyBlob) return u(this._bodyBlob);\n          if (this._bodyArrayBuffer) return Promise.resolve(c(this._bodyArrayBuffer));\n          if (this._bodyFormData) throw Error(\"could not read FormData body as text\");\n          return Promise.resolve(this._bodyText);\n        }, m.formData && (this.formData = function () {\n          return this.text().then(h);\n        }), this.json = function () {\n          return this.text().then(JSON.parse);\n        }, this;\n      }\n\n      function p(e) {\n        var t = e.toUpperCase();\n        return _.indexOf(t) > -1 ? t : e;\n      }\n\n      function l(e, t) {\n        t = t || {};\n        var r = t.body;\n\n        if (e instanceof l) {\n          if (e.bodyUsed) throw new TypeError(\"Already read\");\n          this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new n(e.headers)), this.method = e.method, this.mode = e.mode, r || null == e._bodyInit || (r = e._bodyInit, e.bodyUsed = !0);\n        } else this.url = e + \"\";\n\n        if (this.credentials = t.credentials || this.credentials || \"omit\", !t.headers && this.headers || (this.headers = new n(t.headers)), this.method = p(t.method || this.method || \"GET\"), this.mode = t.mode || this.mode || null, this.referrer = null, (\"GET\" === this.method || \"HEAD\" === this.method) && r) throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n\n        this._initBody(r);\n      }\n\n      function h(e) {\n        var t = new FormData();\n        return e.trim().split(\"&\").forEach(function (e) {\n          if (e) {\n            var r = e.split(\"=\"),\n                o = r.shift().replace(/\\+/g, \" \"),\n                n = r.join(\"=\").replace(/\\+/g, \" \");\n            t.append(decodeURIComponent(o), decodeURIComponent(n));\n          }\n        }), t;\n      }\n\n      function y(e) {\n        var t = new n();\n        return e.split(/\\r?\\n/).forEach(function (e) {\n          var r = e.split(\":\"),\n              o = r.shift().trim();\n\n          if (o) {\n            var n = r.join(\":\").trim();\n            t.append(o, n);\n          }\n        }), t;\n      }\n\n      function b(e, t) {\n        t || (t = {}), this.type = \"default\", this.status = \"status\" in t ? t.status : 200, this.ok = this.status >= 200 && 300 > this.status, this.statusText = \"statusText\" in t ? t.statusText : \"OK\", this.headers = new n(t.headers), this.url = t.url || \"\", this._initBody(e);\n      }\n\n      if (!e.fetch) {\n        var m = {\n          searchParams: \"URLSearchParams\" in e,\n          iterable: \"Symbol\" in e && \"iterator\" in Symbol,\n          blob: \"FileReader\" in e && \"Blob\" in e && function () {\n            try {\n              return new Blob(), !0;\n            } catch (e) {\n              return !1;\n            }\n          }(),\n          formData: \"FormData\" in e,\n          arrayBuffer: \"ArrayBuffer\" in e\n        };\n        if (m.arrayBuffer) var v = [\"[object Int8Array]\", \"[object Uint8Array]\", \"[object Uint8ClampedArray]\", \"[object Int16Array]\", \"[object Uint16Array]\", \"[object Int32Array]\", \"[object Uint32Array]\", \"[object Float32Array]\", \"[object Float64Array]\"],\n            w = function (e) {\n          return e && DataView.prototype.isPrototypeOf(e);\n        },\n            g = ArrayBuffer.isView || function (e) {\n          return e && v.indexOf(Object.prototype.toString.call(e)) > -1;\n        };\n        n.prototype.append = function (e, o) {\n          e = t(e), o = r(o);\n          var n = this.map[e];\n          this.map[e] = n ? n + \",\" + o : o;\n        }, n.prototype.delete = function (e) {\n          delete this.map[t(e)];\n        }, n.prototype.get = function (e) {\n          return e = t(e), this.has(e) ? this.map[e] : null;\n        }, n.prototype.has = function (e) {\n          return this.map.hasOwnProperty(t(e));\n        }, n.prototype.set = function (e, o) {\n          this.map[t(e)] = r(o);\n        }, n.prototype.forEach = function (e, t) {\n          for (var r in this.map) this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this);\n        }, n.prototype.keys = function () {\n          var e = [];\n          return this.forEach(function (t, r) {\n            e.push(r);\n          }), o(e);\n        }, n.prototype.values = function () {\n          var e = [];\n          return this.forEach(function (t) {\n            e.push(t);\n          }), o(e);\n        }, n.prototype.entries = function () {\n          var e = [];\n          return this.forEach(function (t, r) {\n            e.push([r, t]);\n          }), o(e);\n        }, m.iterable && (n.prototype[Symbol.iterator] = n.prototype.entries);\n        var _ = [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"];\n        l.prototype.clone = function () {\n          return new l(this, {\n            body: this._bodyInit\n          });\n        }, f.call(l.prototype), f.call(b.prototype), b.prototype.clone = function () {\n          return new b(this._bodyInit, {\n            status: this.status,\n            statusText: this.statusText,\n            headers: new n(this.headers),\n            url: this.url\n          });\n        }, b.error = function () {\n          var e = new b(null, {\n            status: 0,\n            statusText: \"\"\n          });\n          return e.type = \"error\", e;\n        };\n        var T = [301, 302, 303, 307, 308];\n        b.redirect = function (e, t) {\n          if (-1 === T.indexOf(t)) throw new RangeError(\"Invalid status code\");\n          return new b(null, {\n            status: t,\n            headers: {\n              location: e\n            }\n          });\n        }, e.Headers = n, e.Request = l, e.Response = b, e.fetch = function (e, t) {\n          return new Promise(function (r, o) {\n            var n = new l(e, t),\n                i = new XMLHttpRequest();\n            i.onload = function () {\n              var e = {\n                status: i.status,\n                statusText: i.statusText,\n                headers: y(i.getAllResponseHeaders() || \"\")\n              };\n              e.url = \"responseURL\" in i ? i.responseURL : e.headers.get(\"X-Request-URL\"), r(new b(\"response\" in i ? i.response : i.responseText, e));\n            }, i.onerror = function () {\n              o(new TypeError(\"Network request failed\"));\n            }, i.ontimeout = function () {\n              o(new TypeError(\"Network request failed\"));\n            }, i.open(n.method, n.url, !0), \"include\" === n.credentials && (i.withCredentials = !0), \"responseType\" in i && m.blob && (i.responseType = \"blob\"), n.headers.forEach(function (e, t) {\n              i.setRequestHeader(t, e);\n            }), i.send(void 0 === n._bodyInit ? null : n._bodyInit);\n          });\n        }, e.fetch.polyfill = !0;\n      }\n    }(\"undefined\" != typeof self ? self : this);\n  }, function (e, t, r) {\n    \"use strict\";\n\n    function o(e, t) {\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function n(e, t) {\n      if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n    }\n\n    function i(e, t) {\n      if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n      e.prototype = Object.create(t && t.prototype, {\n        constructor: {\n          value: e,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);\n    }\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n\n    var a = function () {\n      function e(e, t) {\n        for (var r = 0; t.length > r; r++) {\n          var o = t[r];\n          o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n        }\n      }\n\n      return function (t, r, o) {\n        return r && e(t.prototype, r), o && e(t, o), t;\n      };\n    }(),\n        s = r(3),\n        u = function (e) {\n      return e && e.__esModule ? e : {\n        default: e\n      };\n    }(s);\n\n    \"https:\" !== location.protocol && \"localhost\" !== location.hostname && console.warn(\"getUserMedia() must be run from a secure origin: https or localhost.\\nChanging protocol to https.\"), navigator.mediaDevices || navigator.getUserMedia || console.warn(\"Your browser doesn't support navigator.mediaDevices.getUserMedia and navigator.getUserMedia.\"), navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n    var c = window.MediaStream || window.webkitMediaStream;\n    void 0 === c || \"stop\" in c.prototype || (c.prototype.stop = function () {\n      (void 0).getAudioTracks().forEach(function (e) {\n        e.stop();\n      }), (void 0).getVideoTracks().forEach(function (e) {\n        e.stop();\n      });\n    });\n\n    var d = function (e) {\n      function t() {\n        var e, r, i, a;\n        o(this, t);\n\n        for (var s = arguments.length, u = Array(s), c = 0; s > c; c++) u[c] = arguments[c];\n\n        return r = i = n(this, (e = t.__proto__ || Object.getPrototypeOf(t)).call.apply(e, [this].concat(u))), i.state = {\n          asked: !1,\n          permission: !1,\n          available: !1,\n          recording: !1,\n          paused: !1\n        }, i.stream = null, i.mediaRecorder = null, i.mediaChunk = [], i.handleSuccess = function (e) {\n          i.props.autoPlay && i.props.setStreamToVideo(e), i.stream = e, i.mediaChunk = [], i.setState({\n            permission: !0,\n            asked: !0,\n            recording: !1\n          }), i.props.onGranted(), i.initMediaRecorder();\n        }, i.handleFailed = function (e) {\n          i.setState({\n            asked: !1\n          }), i.props.onDenied(e);\n        }, i.getUserMedia = function () {\n          var e = i.props.constraints;\n          if (navigator.mediaDevices) navigator.mediaDevices.getUserMedia(e).then(i.handleSuccess).catch(i.handleFailed);else if (navigator.getUserMedia) navigator.getUserMedia(e, i.handleSuccess, i.handleFailed);else {\n            var t = \"Browser doesn't support UserMedia API. Please try with another browser.\";\n            console.warn(t), i.props.onError(Error(t));\n          }\n        }, i.initMediaRecorder = function () {\n          try {\n            var e = {},\n                t = [\"video/webmcodecs=vp8\", \"video/webm\", \"\"];\n            i.props.mimeType && t.unshift(i.props.mimeType);\n\n            for (var r = 0; t.length > r; r++) {\n              var o = t[r];\n\n              if (MediaRecorder.isTypeSupported(o)) {\n                e.mimeType = o;\n                break;\n              }\n\n              console.warn(o + \" is not supported on your browser.\");\n            }\n\n            var n = new MediaRecorder(i.stream, e);\n            n.ondataavailable = function (e) {\n              e.data && e.data.size > 0 && i.mediaChunk.push(event.data);\n            }, i.mediaRecorder = n, i.setState({\n              available: !0\n            });\n          } catch (e) {\n            console.log(e), console.error(\"Failed to initialize MediaRecorder.\", e), i.setState({\n              available: !1\n            });\n          }\n        }, i.start = function () {\n          i.state.available && (i.mediaChunk = [], i.mediaRecorder.start(i.props.timeSlice), i.setState({\n            recording: !0\n          }), i.props.onStart(i.stream));\n        }, i.pause = function () {\n          i.state.recording && (i.mediaRecorder.stop(), i.setState({\n            paused: !0\n          }), i.props.onPause());\n        }, i.resume = function () {\n          i.state.recording && (i.initMediaRecorder(), i.mediaRecorder.start(i.props.timeSlice), i.setState({\n            paused: !1\n          }), i.props.onResume(i.stream));\n        }, i.stop = function () {\n          if (i.state.available) {\n            i.mediaRecorder.stop(), i.setState({\n              recording: !1\n            });\n            var e = new Blob(i.mediaChunk, {\n              type: \"video/webm\"\n            });\n            i.props.onStop(e), i.getUserMedia();\n          }\n        }, a = r, n(i, a);\n      }\n\n      return i(t, e), a(t, [{\n        key: \"componentDidMount\",\n        value: function () {\n          this.getUserMedia();\n        }\n      }, {\n        key: \"componentWillUnmount\",\n        value: function () {\n          this.mediaRecorder = null, this.mediaChunk = [], this.stream.stop(), this.stream = null;\n        }\n      }, {\n        key: \"render\",\n        value: function () {\n          return u.default.createElement(\"div\", {\n            className: this.props.className\n          }, this.props.render({\n            start: this.start,\n            stop: this.stop,\n            pause: this.pause,\n            resume: this.resume\n          }));\n        }\n      }]), t;\n    }(s.Component);\n\n    d.defaultProps = {\n      constraints: {\n        audio: !0,\n        video: !0\n      },\n      autoPlay: !0,\n      className: \"\",\n      timeSlice: 0,\n      mimeType: \"\",\n      setStreamToVideo: function () {},\n      render: function () {},\n      onGranted: function () {},\n      onDenied: function () {},\n      onStart: function () {},\n      onStop: function () {},\n      onPause: function () {},\n      onResume: function () {},\n      onError: function () {}\n    }, t.default = d;\n  }, function (t, r) {\n    t.exports = e;\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}